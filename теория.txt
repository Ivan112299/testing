1. ==== async и defer ====
2. ==== Прототипное наследование ====



 ==== БАЗА JS ====


===============================
===       БАЗА JS           ===
===============================

===Циклы, условия (if/else/else if), тернарный оператор, Switch-case ===
    тут все понятно вроде

=== Массивы: push(), concat(), slice(), splice(), filter(), map(), reduce() ===
    push() - добавить элемент в конец массива
    concat() - обединяет элементы/массивы в новый массив. если объект передать то не разложит, добавит как обект
    slice() - выбрать элементы строки с какого то по каой то или до конца строки если второй аргумент не передали
    splice() - удалет элемент из массива. Два аргумента - позиция, и сколько элементов начиная с нее удалить
    filter() - фильр по массиву - если тру - берем элемент, фулс - выбрасываем.
    map() - над каждым элементом вызывается функция и возвращается массив результатов применения этой функции. Не м еняет существующий ммассив.
    reduce() - тоже вызывается функция, но результат передается в следующий вызов (accumulator есть)
    some()  - вернет true если по одному из элементов колбэк вернут true
    every() - вернет true если по каждому элемнту колбэк вернет true

=== var, let, const — в чем разница? ===
    const - постоянная, не меняется, хотя элементы объекта можно менять
    var - устарела и глобальная, доступна до объявления
    let - ограничена областью {...}, недоступна до объявления, для каждой итерации в цикле создается своя (тут не совсем понял)

=== JavaScript область видимости. ===
    Области видимости определяют доступность переменных
    Создаются блоками, функциями и модулями.
    var не имеет блочной области
    Переменные объявленные  во внешне йобласти достпуны во вложенныой

=== Типы данных, optional chaining, деструктивное присваивание, замыкание. ===
    Number (NaN - результат неправильной вычислительной операции)
    String
    Boolean
    Null - отдельный тип, "ничего"
    undefined - не определено, не присвоено
    object - единственный не примитивный
    bigint  101n 
    symbol

    optional chaining - опциональная цепочка (animal.dog?.korgi?.name) - dog и korgi могут быть не определены
    деструктивное присваивание: 
        [a, b] = [1, 2]
        [a, b, ...rest] - тут rest разложим в массив
        ({a, b} = {a:1, b:2})
        ({a, b, ...rest} = {a:1, b:2, c:3, d:4}); - тут c3 d4 соберем в объект
    Замыкание  – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
    Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями.
    То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], 
    и все они могут получить доступ к внешним переменным.
    Замыкание это когда функция фозвращает другую функцию и вот как раз она замкнута на область фидимости изначальной функции.
    Лексическое окружение - это то где функция объявлена (не вызвана)

=== Функции JavaScript. Что такое функция? Spread и rest операторы. ===
    Функции что-то возвращают. Методы нет. 
    Function Declaration – функция, объявленная в основном потоке кода. (function name(){...})
    Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.(let name = function(){...})
    Function Declaration можно вызвать до объявления, а  Expression нет
    rest - оператор расширения
        function f(arg1, arg2, ...rest ) { все что передадим как аргументы функции rest соберет в массив}
    spread  - наоборот
        fn(...arr1, ...arr2 ) - при вызове функции такой оператиор наоборот распакует массив по отдельным объектам ([0, ...arr, 2, ...arr2] - так тоже можно)
    
=== Обработка ошибок try-catch ===
    try {...} 
    catch(exception) {...}      // передаем ошибку
    finally {...}               // выполнится в любом случае

=== Что такое callback? ===
    callback - функция, которая передается как аргумент
    колбэки обеспечивают последовательность выполнения функций, а не асинхронность.
    Т.е. точно уверены что вот сейчас выполнится следующая функция

=== Promise, async/await, цепочка промисов. ===
    async function GetUsers() - объявление асинхронной функции
    асинхронные функции - запускаются, а код продолжает выполнятся, 
    как только стек освобождается возвращается результат асинхронной функции
    Цепочка промисов - это когда результат одного промиса передам в следующий промис


===============================
===    БАЗА TypeScript      ===
===============================


==========  Для чего нужен тип never, как используется? =========
Псевдо-тип never означает, что функция никогда не возвращает значения. Такое может быть, например, в случае если функция всегда выбрасывает исключение
Как используется не совсем понял.

=============  Что такое type union =======
Это комбинирование типов. let a: String | Number - можетт принимать значения этих типов. можем прменять методы которые достпуны
 только для каждого из этих типов, иначе получим ошибку.


=========== Что такое enum?	 ============== 
Перечисление именованных констант. Как правило так и используется: 
enum Season { 
    Winter = "Зима", 
    Spring = "Весна",
    Summer = "Лето", 
    Autumn = "Осень"
};

======== Что такое статические и динамические методы класса?	================

============= В чем разница между модификаторами доступа protected и private?	============
protected - защищенные методы, их можно юзать только в экземпляров класса и классов которые extends основной (в подклассах)
private - доступны только внутри класса, и не доступны для подклассов.
private  и protected  свойства можно получить через геттеры и сеттеры


JavaScript	
======== Посмотреть подробнее деструктивное присванивание: для объектов, для массивов, с использованием иных имен, чем имена полей объектов, записываемых в переменную/константу.	======
let obj = {
    age: 20,
    name: 'Иван'
}
let {age = 10, neme = 'Имя по умолчанию'} = obj     // тут присвоил имя двум переменным но при этом если не задачть объект задал значнеия оп умолчанию 
let {age: myAge, neme: myName} = obj                // присволи двум переменныем значения из св. объекта (при этом переименовали)

const arr = ['Name', 'Age', 'SecondName']
let [name, age, secondName] = arr                   // переменным name, age, secondName присвоил значнеия из массивва
let [name, age, secondName, myVar = 'rand'] = arr   // переменным name, age, secondName присвоил значнеия из массивва, последней задал значение по умолчанию

======== Rest и Spread ============
Spread - распростарянять, раскладыает массив  в новый массив
const tvSeriesOne = ['Ozark', 'Fargo', 'Dexter'];
const tvSeriesTwo = ['Mr. Robot', 'Barry', 'Suits'];
const tvSeries = [...tvSeriesOne, ...tvSeriesTwo];

Rest - собиарет значения и формирует из них массив
Используется когда в функцию передаем много значений, а rest осбирает их массив


===============================
===      БАЗА ANGULAR       ===
===============================

ЯНВАРЬ:

1.  ---- Выполнение http-запросов средствами Angular. HttpClient.-----------

    Сделано. Подключаем модулиь HttpClientModule. Его методы возвращают observable(стрим, поток), подписываемся на них и в этот момент выполняется запрос. 

2.  ---- Что такое Observable, subscribe(), Subscription. (RxJS) -------

    subscribe принимает в себя 3 функции: next(), error(), completed - последние две не обязательные
    стрим - как раз имеет тип Subscription и возвращает observable
    Кладем результат работы subscribe в переменную, и у нее можно вызвать unsubscribe() - отписаться
    у стрима можно вызвать операторы (много, описание в документации) через .pipe() - преобразование данных перед возвратом

3. ---- Формы Angular: виды форм (Template driven forms, Reactive forms). Биндинг (двусторонний, односторонний).

    Template - реализуются в шаблонах, редко используются, импортим FormsModule
     - помни что у form-контролов есть состояния которые мы можем отслеживать (6 классов - валидность, трогали или нет..) через эти классы и можно валидировать, выводить подсказки 
    Reactive - то что на курсе рассмотрели. Импортирум в этом случае  ReactiveFormsModule. инициализация форм происходит не в шаблоне. 
    FormGroup - это обединяющая сущность для всех полей формы. Через нее можно уже к остальным полям обращаться
    Все валидации внутри делаем. Для описания модели формы можно использовать formbuilder (инжектируем в конструктор и через него создаем модель)
    FormArray - реализовал, главный плюс что можем динамически добавлять удалять поля. Главное все связать не забыть и кнопкам накинуть тип button

4. ----- Валидация в каждом виде форм. --------
    Для templateForm - у form-контролов есть состояния которые мы можем отслеживать (6 классов - валидность, трогали или нет..) через эти классы и можно валидировать, выводить подсказки 
    Reactive Form - для них в модель формы передаем разные валидаторы (в т.ч. пишем свои при необходимости)
    Свой валидатор: По сути класс, в отдельном файле? имплементируемся от PipeTransform. Пишем логику что и как будем обрабатывать. Не забвам подключить в NgModule({ declarations: [].
    См комит по создания своего пайпа в проекте.

Дополнительно по итогам:

--- Guards ---

    Guards - защита роутов. пишем отдельный сервис, внутри класс имплементируемся от CanActivate. Внутри реализуем метод CanActivate() - где логика что проверяем, возвращает true/false. 
    Дальше в файле где описан роутинг нужной странице добавляем canActivate: [AuthGuard] или canActivateChild[]  - если роут дочерний

---- Template form и Reactive Form ----

    Template - реализуются в шаблонах, редко используются, импортим FormsModule
        - помни что у form-контролов есть состояния которые мы можем отслеживать (6 классов - валидность, трогали или нет..) через эти классы и можно валидировать, выводить подсказки 
    Reactive - то что на курсе рассмотрели. Импортирум в этом случае  ReactiveFormsModule. инициализация форм происходит не в шаблоне. 
    FormGroup - это обединяющая сущность для всех полей формы. Через нее можно уже к остальным полям обращаться
    Все валидации внутри делаем. Для описания модели формы можно использовать formbuilder (инжектируем в конструктор и через него создаем модель)
    FormArray - реализовал, главный плюс что можем динамически добавлять удалять поля. Главное все связать не забыть и кнопкам накинуть тип button

---- BehaviorSubject, ReplaySubject, Subject -----

    Subject  - это класс (как observable), на изменения в экземпляре этого класса можно не только подписываться, но и эмиттеть можем события через next()
    BehaviorSubject - это Subject с предустановленным значением. последнее сохраненное значение отправит всем подписчикам. 
        const bs$ = new BehaviorSubject(10)
        bs$.next(20) - дали новое значение и заэмитили событие которое всем подписчикам улетит и они сразу его получат 
    ReplaySubject - это Subject но с возможностью сохранения нескольких значений. При инициализации указываем размер буфера значений. 
        const rs$ = new ReplaySubject(2) 
        rs$.next(3)
        rs$.next(3)
        rs$.next(3) - это уже не запишется, т.к. буфер 2.

---- Subscription, как закрывается подписка на Observable -----

    1. в OnDestroy через unsubscribe()
    2. при передаче значения в шаболон можно прменить async пайп {{observable$ | async}}
    3. Использовать оператор RxJ Stake(n), takeUntil(notifier), takeWhile(predicate)
    4. Или можно написать свой декоратор и применить к классу (пробежится, надет стримы, отпишется)
    https://habr.com/ru/post/484762/

---- Что такое модуль Angular, что такое сервис в Angular. ---

    1. Angular модуль - это класс с декоратором @NgModule(), который служит изолирующей логической объединяющей структурой для компонентов, директив, фильтров и сервисов.
    Все перечисленные сущности определяются и конфигурируются с помощью @NgModule(). Внутри @NgModule() указываем какие модули импортируем, экспортируем, какие Компоненты и директивы есть (массив declarations), какие сервисы (массив providers)
    2. Service - часть модуля, служит для поставки данных, а не для отображения

ФЕВРАЛЬ:

1. ----- Angular: что такое provider'ы https://angular.io/guide/dependency-injection-providers? ------
    Это массив внутри ngModule где указываем какие сервисы нужно инжектировать в модуль. Для этого сервси долежн быть
    @NgModule({
    providers: [DepositsService]
    })
   ----- Что такое Depndency injection? Чем отличаются providers в модуле и в компоненте? ------------
   providers в модуле - создает экземпляр класса на уровене модуля
   providers в компоннете  - на уровне компонента 
   Если и там и там инжектируем - создастся два экземпляра
   паттерн проектирования. Возможность использвания компонентами, директивами разных  сервисов. Для этого сервис делается @Injectable({ providedIn: 'root' })

    https://angdev.ru/doc/dependency-injection/#angular-providers

2. ----- Что такое interceptors? -----------

    Это класс наследуемый от  implements HttpInterceptor.
    Angular HTTP Interceptor позволяет перехватывать HTTP-запросы перед их отправкой и вносить в них необходимые изменения. То же самое справедливо и для ответов сервера. Регистрируем в app.module в разделе providers. Предварительно создав: 
    const INTERCEPTOR_PROVIEDER: Provider = {
    provide: HTTP_INTERCEPTORS,
    multi: true,
    useClass: AuthInterceptor

3. ----- State management: Mobx.js. actions, computed, observable, reactions. (получить представление) ------

4. ----- Роутинг -----------
    1. Ленивая подгрузка модулей (асинхронная маршрутизация) - загрузка при обращении. Реализовано на примере админки.
    2. Роутинг - отдельный модуль RouterModule. Импортируем Routing. Дальше указываем адрес и какой компонент туда грузить. 
        Можно указать дочерние роуты, redirectTo. AppRoutingModule  импортируется в модуль, для которого создается навигация. Компоненты загружаются в <router-outlet></router-outlet>
        Для перехода по роуту на <a> вешаем [routerLink] + routerLinkActive="клаас_при_активации"
    3. чтение параметров из адресной строки,  - получить параметры позволяет  ActivatedRoute - параметры получаем через subscribe. Что бы параметр в роут передать он передается вторым элементом в 
        <a [routerLink]="['profile', 3]">Profile</a> - тут 3  это как раз параметр.  
    4. Что такое Guards? - защита роутов. Пишем модуль гвардов и передаем их в модель роутов параметром  canActivate: [AuthGuard] (см. файл роутинга)
    5. Что такое резолверы? - выполняет какое-либо действие перед переходом на маршрут, обычно ожидает данные от сервера; По сути это тоже сервис, который получает данные, как то их обрабатывает, но при этом мы указываем в app-routing что это резолвер к этому пути. Возвращает observable. Выполнение метода resolve() (как синхронного, так и асинхронного) инициирует событие NavigationEnd, что можно использовать для скрытия прелоадера при переходах между страницами.


МАРТ: 

1. -------------- State management: Mobx.js. actions, computed, observable, reactions. (получить представление) -----------

помечаем наблюдаемые поля  @observable. При изменении значений необходимо повторный рендеринг
Почемаем получаемые из шаблона поля  через @computed get Variable() { ... } - вычисляет значение на основе наблюдаемых полей
С помощью @action декоратора мы отмечаем методы, которые изменяют наблюдаемые поля. 

Т.е action меняет наблюдаемое поле, мы ренедрим новое значение, computed в этот момент вычисляет новые значения и если нужно рендерит (если значение 
не изменилось рендеринг не требудется, поддерживает данные из кеша)

2. -------------- Статические/динамические классы, методы, поля -----------------------------------

- Статические поля задаются без конструктора, в конструкторе не нужны. К ним можно обратиться напрямую без создания экземпяра класса. 
Динамические поля задаются через конструктор и тут они задаются при создании экземпдяра, доступ к ним через экземпляр.
- Статические методы тоже вызываются просто через класс, не создавая экземпляр. Из статических методов недосутпны динамические поля класса. 
Динамические методы только через экземпляр.
    
3. -------------- Pure и Impure pipes, передача нескольких параметров в пайп ----------------------------------
    По умолчанию все пайпы  - pure (не допускающие изменений) - отслежвают String, Number, Boolean, Symbol. По массивам и объектам следит 
    за ссылками - меняем их, ссылки не меняются, пайп не отрабатывает

    Если пайп impure (допускающие изменений)  - он отслеживает все изменения. 
    Разница в производительности

    @Pipe({
        name: 'join',
        pure: false, - указываем что он impure
    })

    Параметры в пайпы передаются через двоеточие <div>{{ phones | join: 1:3 }}</div>

4. -------------- Подробно изучить https://angular.io/guide/dependency-injection-providers ------------------------------

     - Для того чтобы созданный сервис мог быть использован компонентом или другим сервисом, его объявление должно предваряться декоратором @Injectable({ providedIn: 'root' }).

      - сервисы региструем в app.module на уровне приложения или на уровне модуля, массив providers: [Logger]. при этом создается экземпляр класса. 
      Но можно переопределить класс [{ provide: Logger, useClass: Logger }]
            
            Возможные свойства объекта конфигурации:
            useClass - каждый раз при обращении к зависимости, указанной в provide, создается новый экземпляр класса, указанного в useClass;
            useExisting - каждый раз при обращении к зависимости, указанной в provide, будет использоваться один и тот же экземпляр класса, указанного в useExisting;
            useValue - позволяет при обращении к зависимости, указанной в provide, использовать предопределенный объект;
            useFactory и deps - эти свойства позволяют создавать переопределяющее значение динамически уже в процессе работы приложения.

            providers: [
                {
                    provide: UserService,
                    useFactory: userServiceFactory,
                    deps: [AuthService],
                },
                 {
                    provide: ApiSettingsService,
                    useFactory: apiSettingsServiceFactory,
                    deps: [AppConfigurationService, TokenService]
                    },
                ]

    Для того чтобы сделать возможным внедрение в компонент сущность, не являющуюся сервисом Angular, нужно определить для нее вручную injection token.

            import { InjectionToken } from '@angular/core';
            export const APPLICATION_NAME_TOKEN = new InjectionToken<string>('Application Name');
            export const BASE_HREF_TOKEN = new InjectionToken('BASE HREF');
        
        затем инжектив в конструкторе 

        export class SomeComponent implements OnInit {
            constructor(
                @Inject(APPLICATION_NAME_TOKEN) private defaultSettings,                    // получаем досутп к сущности APPLICATION_NAME_TOKEN (важно - синглтон)
            ) { }
        }

    при объявлении можно пропустить поиск локального сервсиа через декоратор @SkipSelf
       constructor(
            private localDepositsService: DepositsService,
            @SkipSelf() private rootDepositsService: DepositsService
        ) {}
    @Optional() - в случае отсутствия необходимого сервиса во всех Angular injector не будет сгенерировано исключение, а в переменную просто запишется null.


5. -------------- jest, karma  - иметь представление. Юнит тесты - иметь представление, describe(), it(). spy, spyOn(). -------------

jest - пакет
        test(
            'Описание теста',
            () => {
                expect(etstingFunction(param).toBe(factResult))
            }
        )
    или
        it(
            'Описание теста',
            () => {
                expect(etstingFunction(param).toBe(factResult))
            }
        )

    Можно запускать набор тестов через describe (
        'Название', 
        ()=> {
            let testCases = [набор тестовых данных]
            testCases.forEach (
                test =>{
                     it(
                        'Описание теста',
                        () => {
                            expect(etstingFunction(param).toBe(factResult))
                        }
                    )
                }
            )
        },
    )
    toBe - используется для сравнения примитивных типов данных (===)
    toEqual - используется для сравнения объектов 
    toBeDefined(), toBeUndefined() 
    toBeTruthy()
    toBeFalsy()

karma  - файлы имеют название с раширением spec.ts
    describe () - набор
    it() - тест


МАРТ: 


2.4. Создание компонента: 
    - компоненты, директивы, модули в ангуляр - это все классы
    1. создаем папку с компонентом
    2. там файлы шаблон html + ts
    3. регистрируем в app.modules с импортом
    4. добавляем по названию selector основной шаблон 

2.5 Создание компонента через CLI в терминале
    ng generate component post2
    ng generate component post3 --skip-tests

2.6 Можно создать и шаблон и стили прямо внутри файла .ts в компоненте

2.7 Интерполяция - механизм вывода и привязки данных
     - простые данные из ts выводим в шаблон через {{ название_переменной }}
     - тут ангуляр берет значение переменной и приводит к строке .toString()
     - объект к строке не привести - получим [Object Object]

2.8 Bindings - привязка динамики к шаблону (из ts в html)
    - берем в разметке что то в кв. скобки тем самым связывая html с ts
    ПРИМЕР: <img [src]="img" alt="">

2.9 EventBinding  - тут наоборот из html в ts передача событий (как листенеры в js)
    -  в круглых скобках заадем событие а через равно метод обработающий это событие, и передать в этот метод все что нужно
    ПРИМЕР: <button (click)="onClick($event)">Кнопка 1</button>

2.10 Двунаправленныфй биндинг
     - для этого импортируем FormsModule в app.module
    ПРИМЕР: <input type="text" [(ngModel)] = "title2">

2.11 Директива ngStyle - помогают управлять html элементами. Можем динамически менять стили (см. пример в проекте)

2.12 Директива ngClass - можно задавать клаассы по условию, в качестве ключа у объекта выступает название класса
            <div class="testblock" [ngClass]="{
                red: bgToggle_2,  
                yellow: !bgToggle_2
            }"></div>

2.13 Структурные директивы - позволяют изменять структур html шаблона
    *ngIf - управление отображением элемента
        <button (click)="toggle = !toggle">Сменить</button>
        <p *ngIf="toggle; else secondP" class="red testblock">йцуке</p>
        <ng-template #secondP>
            <p class="yellow testblock">фыав</p>
        </ng-template>
    *ngSwitch     - управление отображением элемента (прмер в проекте)
    *ngFor

2.14 Пайпы - трансформеры для отображения элементов. Именно отображенпия, ничего не меняют

================= Компоненты =======================
создание ng generate component post3 --skip-tests
lifecycleHooks - жизненный цикл компоненнта

constructor() - вызывается первым, но логику туда обычно не пишут
ngOnChanges() - вызывается до ngOninit. - возвращает текущий объект, состояние до этого, и первое ли это изменение
ngOninit() - инциализация компонента, после конструктора.
ngDoCheck() - вызыввается во время изменений
ngAfterContentInit() - вызывается после передачи контента
ngAfterContentCheked() - вызывается когда весь контент передан и его можно использовать
ngAfterViewInit() - вызываетя когда проинициализирован вью
ngAfterViewCheked()
ngOnDestroy() - вызывается когда компонент уничтожен (или деректива) - отписываемся от ивент хэндлеров и обсервблов

changeDetectionStrategy - ангуляр постоянно следит за изменениями всех компонентов и в случае изменения перерисовывает
    ChangeDetectionStrategy.OnPush  - реагирует только на изменения через @Input
    ChangeDetectionStrategy.Deafault - стандартное отслеживание

========= Директивы ===========
Создание ng g d directives/style --skip-tests
Директивы в квадратных скобках в разметке html
Через директивы можем иметь доступ к html и по событию что то менять в html (в уроке стили)
атрибутные директивы - меняют атрибутные
Структурные дерективы - меняют структуру

======= Пайпы ============
создание ng g p pipes/filter --skip-tests
Какие то методы как встроенные так и созданные нами, которые позволяют изменить отображаемый контент
из сложного: есть async пайп, который позволяет работаь с обзерваблами, стримами, промисами. С помощью него 
можно не обрабатывать промис а просто указать этот пайп (0ничего не ясно)

====== RxJS ==========
Библиотека. 
Мы можем обернуть кусок когда в стрим, и внутри можем триггерить события а где то на это подписаться (subscribe). 
Затем нужно отписаться от стрима (unsubscribe)
к стримам можно применять разные пайпы - операторы (вызываем пайп и передаем туда оператор нужный)
subscribe принимает в себя 3 функции: next(), error(), completed - последние две не обязательные

import {} from 'rxjs'
import {} from 'rxjs/operators'

========== сервисы ===========
отдеьные сущности, позволяют работать с данными. Так же как и все в ангуляре это классы, причем без декораторов
Хорошей практикой считается добавить декоратор @Injectable()
сервисы можно инжектировать в компоненты, а так же в другие сервисы
Сервис может быть локальным и глобальным, как зарегистрируешь. (почитать про это, не совсем понял)

========== формы ==============
FormArray - так и не разобрался с группами, не создал собственную ngModel

=========  Запросы данных HttpClientModule =================
HttpClient оборачиваются в rxJS. Поэтому выполняются только если на них есть подписка. 
Если нет подписки то и запрос выполнятся не будет
в запросы передаются разные параметры и хедерсы, это разобралс
Так же сть интерсепторы - позволяют перехватывать запросы и что то с ними делать. Зачем  - не совсем ясно.

============ Роутинг ==============
Пример в файле app-routing.module.ts
Разобрался как настроить Роутинг в приложении
Как дочерние страницы отобразить, параметры добавить в адресную строку.
Резолверы - тут не совсем понял - надо дополнительно почтитать